
类型转换（cast）的原意是“模型铸造”，在适当时候，Java会将一种数据类型转换为另一种。

Java不允许将一个数字作为布尔值使用，这在c/c++里是允许的(真是非零，假是零)。在Java中`if(a){}`，需要先用一个条件表达式将a转换为布尔值，例如`if(a!=0){}`。

switch语句要求使用一个选择因子，并且必须是int或char那样的整数值。假如将一个字符串或浮点数作为选择因子使用，它们在switch语句里是不会工作的。或者用enum和switch语句协调工作。

假定你的对象（并非使用new）获得了一块“特殊”的内存区域，由于垃圾回收器只知道释放那些经由new分配的内存，所以它不知道如何释放这块“特殊”内存。这种情况下，Java允许在类中定义一个名为`finalize()`的方法，垃圾回收器会首先调用这个方法（但尽量不要用这个方法）。Java中对象可能不被垃圾回收，垃圾回收并不等于c++中的析构。

看来之所以要有`finalize()`，是由于在分配内存时可能采用了类似C语言中的做法，而非Java中的通常做法。这种情况主要发生在使用"本地方法"的情况下，本地方法是一种在Java中调用非Java代码的方式。

在非Java代码中，也许会调用C的`malloc()`函数系列来分配存储空间，而且除非调用了`free()`函数，否则存储空间将得不到释放，从而造成内存泄露。当然，`free()`是C和C++中的函数，所以需要在`finalize()`中用本地方法调用它。

Java中垃圾回收器并不是采用“引用计数”方式来进行。引用记数是一种简单但速度很慢的垃圾回收技术。每个对象都含有一个引用记数器，当有引用连接至对象时，引用计数加1。当引用离开作用域或被置为null时，引用计数减1。虽然管理引用记数的开销不大，但这项开销在整个程序生命周期中将持续发生。垃圾回收器会在含有全部对象的列表上遍历，当发现某个对象的引用计数为0时，就释放其占用的空间(但是，引用记数模式经常会在记数值变为0时立即释放对象)。这种方陆有个缺陷，如果对象之间存在循环引用，可能会出现"对象应该被回收，但引用计数却不为零"的情况。对垃圾回收器而言，定位这样的交互自引用的对象组所需的工作量极大。

Java中垃圾回收器是"自适应的、分代的、停止-复制、标记-清扫"式垃圾回收器。

Java虚拟机中有许多附加技术用以提升速度。尤其是与加载器操作有关的，被称为"即时" (Just-In-Time，JIT)编译器的技术。这种技术可以把程序全部或部分翻译成本地机器码(这本来是Java虚拟机的工作)，程序运行速度因此得以提升。从不会被执行的代码也许就压根不会被JIT所编译。新版JDK中的Java HotSpot技术就采用了类似方法，代码每次被执行的时候都会做一些优化，所以执行的次数越多，它的速度就越快。

总结一下对象的创建过程，假设有个名为Dog的类:

1. 即使没有显式地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时，或者Dog类的静态方法/静态域首次被访问时， Java解释器必须查找类路径，以定位Dog.class文件。
2. 然后载入Dog.class(这将创建一个Class对象)，有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象首次加载的时候进行一次。
3. 当用`new Dog()`创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间。
4. 这块存储空间会被清零，这就自动地将Dog对象中的所有基本类型数据都设置成了默认值 (对数字来说就是0，对布尔型和字符型也相同)，而引用则被设置成了null。
5. 执行所有出现于字段定义处的初始化动作。
6. 执行构造器。这可能会牵涉到很多动作，尤其是涉及继承的时候。

类既不可以是private的(这样会值得除该类之外，其他任何类都不可以访问它)， 也不可以是protected的。所以对于类的访问权限，仅有两个选择：包访问权限或public。如不希望其他任何人对该类拥有访问权限，可以把所有的构造器都指定为private，从而阻止任何人创建该类的对象，但是有一个例外，就是你在该类的static成员内部可以创建。

可以为每个类都创建一个`main()`方法。这种在每个类中都设置一个`main()`方法的技术可使每个类的单元测试都变得简便易行。而且在完成单元测试之后，也无需删除`main()`，可以将其留待下次测试。

由导出类转型成基类，在继承图上是向上移动的，因此一般称为向上转型。由于向上转型是从一个较专用类型向较通用类型转换，所以总是很安全的。也就是说，导出类是基类的一个超集。它可能比基类含有更多的方法，但它必须至少具备基类中所含有的方法。在向上转型的过程中，类接口中唯一可能发生的事情是丢失方法，而不是获取它们。这就是为什么编译器在"未曾明确表示转型"或"未曾指定特殊标记"的情况下，仍然允许向上转型的原因.

在面向对象编程中，生成和使用程序代码最有可能采用的方法就是直接将数据和方法包装进一个类中，井使用该类的对象。也可以运用组合技术使用现有类来开发新的类，而继承技术其实是不太常用的。因此，尽管在教授OOP的过程中我们多次强调继承，但这并不意味着要尽可能使用它。相反，应当慎用这一技术，其使用场合仅限于你确信使用该技术确实有效的情况。到底是该用组合还是用继承，一个最清晰的判断办法就是问一问自己是否需要从新类向基类进行向上转型。如果必须向上转型，则继承是必要的，但如果不需要，则应当好好考虑自己是否需要继承。只要记得自问一下"我真的需要向上转型吗?"就能较好地在这两种技术中做出决定。

对于基本类型，final使数值恒定不变;而用于对象引用，final使引用恒定不变。一且引用被初始化指向一个对象，就无法再把它改为指向另一个对象。然而，对象其自身却是可以被修改的。

编写构造器时有一条有效的准则:"用尽可能简单的方法使对象进入正常状态；如果可以的话，避免调用其他方法"。在构造器内唯一能够安全调用的那些方法是基类中的final方法(也适用于private方法，它们自动属于final方法)，这些方法不能被覆盖，也就不容易出现怪异问题。




## 集合
集合有两个基本的接口：Collection和Map。还有Set、ListIterator接口等。实在这些接口的类有很多。

Collection接口扩展了Iterable接口，因此对于标准类库中的任何集合都可以使用「for each」循环。

泛型集合接口有一个很大的优点，即算法只需要实现一次。标准的C++类库已经有了几十种非常有用的算法，每个算法都是在泛型集合上操作的。Java类库中的算法没有如此丰富，但是也包含了基本的排序、二分查找等实用算法。

数组可以存放对象，也可以存放基本类型。数组是容器吗？

## 多线程
线程和进程的区别: https://gw.alipayobjects.com/zos/rmsportal/sPHJvmeyIHeUBcQqOmVO.png

操作系统的多任务：在同一时刻运行多个程序的能力。计算机有多个CPU，但是并发执行的进程数目并不是由CPU数目制约的。操作系统将CPU的时间片分配给每一个进程，给人并行处理的感觉。

通常，结程只是一种为单一处理器分配执行时间的手段。但是如果操作系统支持多处理器，那么每个任务都可以被指报给不同的处理器，并且它们是在真正地并行执行。在语言级别上，多钱程所带来的便利之-便是程序员不用再操心机器上是有多个处理器还是只有一个处理器.由于程序在逻辑上被分为钱程，所以如果机器拥有多个处理器，那么程序不需要特殊调整也能执行得更快。

可以同时运行一个以上线程的程序称为多线程程序。多进程与多线程本质区别在于每个进程拥有自己的一整套变量，而线程则共享数据。但共享变量使线程之间的通信比进程之间的通信更有效、更容易。

一些名词：`中断线程`，`线程状态`，`线程属性`，`同步：竞争条件、锁对象、条件对象、死锁`，`阻塞队列`，`线程安全的集合`，`线程池`，`同步器`

构建一个新的线程是有一定代价的，因为涉及与操作系统的交互。如果程序中创建了大量的生命周期很短的线程，应该使用「线程池」。一个线程池中包含许多准备运行的空闲线程。


## Java I/O
I/O操作的都是字节而不是字符。字符到字节必须要经过编码转换，而这个编码又非常耗时，而且会经常出现乱码问题。

访问文件的方式：内核缓存访问、磁盘访问、同步与异步方式访问、内存映射方式访问。

Java序列化就是将一个对象转化成一串二进制表示的字节数组。需要持久化，对象必须继承`java.io.Serializable`接口。反序列化则是相反的过程，将这个字节数组再重新构造成对象（反序列化必须有原始类作为模板，才能将这个对象还原）。

影响网络传输的因素：网络带宽，传输距离（数据在光纤中移动并不是走直线的、会有一个折射率、导致速度减小为光速的约2/3 产生传输延时），TCP拥塞控制。

主机A的应用程序要能和主机B的应用程序通信，必须通过Socket建立连接。建立TCP连接需要底层的IP协议(网络层)来寻址网络中的主机。但一台主机上可能运行着多个应用程序，需要通过TCP和UDP的地址也就是「端口」来指定某个应用程序。

### I/O调优
- 磁盘I/O优化
    - 性能检测
    - 增加缓存，减少磁盘访问次数
    - 优化磁盘管理系统
    - 设计合理的磁盘存储数据块，以及访问策略
    - 应用合理的RAID策略提升磁盘I/O
- TCP网络参数调优
    - 增大端口数
    - 让Tcp连接复用
- 网络I/O优化
    - 减少网络交互次数（如js文件的combo请求）
    - 减少网络传输数据量的大小（如web页面gzip压缩） 


## Javac编译原理
Javac是一种编译器，能将一种语言规范转成另一种语言规范，通常编译器都是将便于人理解的语言规范转化成机器容易理解的语言规范，如C、C++或者汇编语言都是将源码直接编译成目标机器码，这个目标机器码是CPU直接执行的指令集合。Javac的任务就是将Java源代码先转换成jvm能够识别的一种语言（从.java文件转为.class文件），然后由jvm将jvm语言再转换成当前这个机器能够识别的机器语言。

Javac主要有四大模块：词法分析器、语法分析器、语义分析器、代码生成器。词法分析的结果就是把Java源文件中的字符流转换成对应的符合规范的token流。语法分析的结果是形成一个符合Java语言规范的抽象语法树，它的作用是把语言的主要词法用一个结构化的形式组织在一起。语义分析的结果是将复杂的语法转化成最简单的语法、如将foreach转换成for循环结构，形成一个注解过后的抽象语法树，更接近目标语言的语法规则。代码生成器的结果是生成符合Java虚拟机规范的字节码。

## 深入class文件结构
Java是跨平台的，一次编译到处运行。这个编译好的class文件到底是什么样？为何它能够到处运行？

## 深入分析ClassLoader工作机制
ClassLoader就是类加载器，负责将class加载到JVM中；还能审查每个类应该由谁加载、它是一种父优先的等级加载机制；还有一个任务就是将class字节码重新解析成JVM统一要求的对象格式。

内容比较复杂，一些关键词：`defineClass()`、`findClass()`、`loadClass()`、`ExtClassLoader`、`AppClassLoader`、`URLClassLoader`、`ClassNotFoundException`、`NoClassDefFoundError`、`StandardClassLoader`、`WebappClassLoader`、

查看classloader：

    //《深入分析Java Web技术内幕》p166
    ClassLoader classLoader = this.getClass().getClassLoader();
    while(classLoader != null){
        System.out.print(classLoader.getClass().getCanonicalName());
        classLoader = classLoader.getParent();
    }

#### ClassLoader能完成的事情如下：
- 在自定义路径下查找自定义的class类文件，也许我们需要的class文件并不总是在已经设置好的ClassPath下面，那么需要自己实现一个ClassLoader来找到这个类。
- 对我们自己的要加载的类做特殊处理，如保证通过网络传输的类的安全性，可以将类经过加密后再传输，在加载到JVM之前需要对类的字节码再解密，就可以在自定义的ClassLoader中实现。
- 我们可以检查已经加载的class文件是否被修改，如果修改了，可以重新加载这个类，从而实现类的热部署。

#### Java应不应该动态加载类
用Java的一个痛处就是，如果修改一个类，必须要重启一边，很费时。于是能否来个动态类的加载而不需要重启JVM？不应该这样。

Java的优势正是基于共享对象的机制，达到信息的高度共享，也就是通过保存并持有对象的状态而省去类信息的重复创建和回收。对象一旦被创建，这个对象就可以被人持有和利用。

对象的引用关系只有对象的创建者持有和使用，JVM不可以干预对象的引用关系，因为JVM并不知道对象是怎么被使用的，这就涉及JVM并不知道对象的运行时类型而只知道编译时类型。假如一个对象的属性结构被修改，但是运行时其他对象可能仍然引用该属性。

前面分析的造成不能动态提供类对象的关键是，对象的状态被保存了，并且被其他对象引用了，一个简单的解决办法就是不保存对象的状态，对象被创建使用后就被释放掉，下次修改后，对象也就是新的了。这就是`JSP`，它难道不是可以动态加载类吗？其实所有其他解释型语言都是如此。


## JVM
以计算为中心看计算机的体系结构可分为几部分：指令集；计算单元；寻址方式；寄存器定义；存储单元。指令集就是CPU中用来计算和控制计算机系统的一套指令的集合，指令集的先进与否关系到CPU的性能发挥，体现CPU性能的一个重要标志。当前计算机中指令集主要分为：精简指令集（RISC）和复杂指令集（CISC），桌面操作系统中普遍使用CISC。

机器如何执行代码？JVM为何选择基于栈的架构？（p183-185）

JVM的结构基本由4部分组成：类加载器；执行引擎；内存区；本地方法调用。执行引擎是核心部分，用来解析JVM字节码指令，得到执行结果。在《Java虚拟机规范》中规定了执行引擎执行字节码时应该处理什么、得到什么结果，但并没有规定执行引擎应该采取什么方式处理而得到这个结果，具体采取什么方式由JVM的实现厂家自己去实现、如SUN的hotspot是基于栈的执行引擎，而Google的Dalvik是基于寄存器的执行引擎。

每一个Java线程就是一个执行引擎实例，一个JVM实例中就会同时有多个执行引擎在工作，这些执行引擎有的在执行用户的程序，有的在执行JVM内部的程序（如Java垃圾收集器）。

### 内存管理
堆栈图: https://gw.alipayobjects.com/zos/rmsportal/VpwONqGFCQIOuJLLFbvu.png

通常操作系统管理内存的申请空间是按照进程来管理的，每个进程拥有一段独立的地址空间，每个进程之间不会相互重合，操作系统也会保证每个进程只能访问自己的内存空间。

几个名词：`物理内存和虚拟内存`、`RAM`、`地址总线与总线宽度`、`内核空间与用户空间`、`静态/动态内存分配和回收`

Java堆是用于存储Java对象的内存区域，堆的大小在JVM启动时就一次向操作系统申请完成，一旦分配完成，堆的大小就不能再改变。Java堆中内存空间的管理由JVM控制，对象创建由Java应用程序控制，但对象所占的空间释放由管理堆内存的垃圾收集器来完成。  
堆是被所有Java线程所共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。

JVM运行实际程序的实体是线程，每个线程创建时JVM都会为它创建一个堆栈，堆栈的大小根据不同的JVM实现而不同。一个线程的方法的调用和返回对应于这个Java栈的压栈和出栈。

栈中主要存放一些基本类型的变量数据（int、short、long、byte、float、double、boolean、char）和对象句柄（引用），方法执行结束此处变量也就会消失。存取速度比堆要快，仅次于寄存器，栈数据可以共享。缺点是，存在栈中的数据大小与生存期必须是确定的，这样导致缺乏了其灵活性。

每一个Java应用都唯一对应一个JVM实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组等对象都放在这个堆中，并由应用程序所有的线程共享（方法执行完成后不一定就消失、可能仍被别的线程对象引用）。在建立一个对象时两个地方都要分配内存，在堆中分配的内存实际建立这个对象，而在栈中分配的内存只是一个指向这个堆对象的指针（引用）而已。

new一个对象的内部过程，在内存的栈中的操作过程？
一个方法里边的局部变量等分别占用多少内存空间？
内存泄露分析实例

从堆和栈的功能和作用来通俗地比较，堆主要用来存放对象，栈主要用来执行程序，这种不同主要是由堆和栈的特点决定的。

淘宝正在开发一种技术用于在JVM中分配另外一个内存存储区域，它不需要GC回收期来回收，但是可以和其他内存中对象一样来使用。


## Servlet工作原理解析
servlet 其实就是一个 Java 类，所有的servlet类都必须继承 HttpServlet 类。
生命周期：服务器会在启动或第一次请求servlet时初始化一个servlet对象，然后使用该对象处理客户端的请求，当服务器关闭时销毁该对象。

Servlet容器有：Tomcat、Jetty等。Tomcat的容器分为四个等级，真正管理Servlet的容器是Context容器，一个Context对应一个web工程。

与Servlet主动关联的三个类：ServletConfig、ServletRequest、ServletResponse，这三个类都是通过容器传递给Servlet的，其中ServletConfig在Servlet初始化时就传给Servlet了，而后两个是在请求到达时调用Servlet传递过来的。

用户浏览器向服务器发起一个请求通常会包含如下信息：http://hostname:port/contextpath/servletpath/。hostname和port用来与服务器建立TCP链接，而后面的URL才用来选择服务器中哪个子容器服务用户的请求。

Filter也是在web.xml中的另一个常用配置项，可以通过`<filter>和<filter-mapping>`组合来使用Filter。它可以完成与Servlet同样的工作，甚至比Servlet使用起来更加灵活。（是否类似中间件？）

现在的Web应用很少直接将交互全部页面都用Servlet来实现，而是采用更加高效的MVC框架来实现。这些MVC框架的基本原理是将所有的请求都映射到一个Servlet，然后去实现service方法，这个方法也就是MVC框架的入口。


## 深入理解Session与Cookie
Session 默认有效期是关闭浏览器，为什么session会消失，主要原因是浏览器端cookie内保存的 sessionID 失效了，因为session是基于cookie的，所以关闭浏览器会失效。浏览器关闭，session是不会马上消失的。如何延长session声明周期，解决方案：延长cookie 和 session 的生存时间

Cookie可以让服务端程序跟踪每个客户端的访问，但是每次客户端的访问都必须传回这些Cookie，如果数量很多，这就增加了客户端与服务端的数据传输量，而Session解决了这个问题。

同一个客户端每次和服务端交互时，不需要都传回所有的Cookie值，而是只要传回一个id，这个id是客户端第一次访问服务器时生成的，而且每个客户端是唯一的。这个id通常是name为JSESIONID的一个Cookie。

由于Cookie是存储在客户端浏览器里的，不安全很容易被修改。相比之下，Session是将数据保存在服务端，只是通过Cookie传递一个SessionID而已，所以Session更适合存储用户隐私和重要的数据。

分布式Session框架可以解决的问题：Session配置的统一管理；Cookie使用的监控和统一规范管理；Session存储的多元化；Session配置的动态修改；Session加密key的定期修改；充分的容灾机制，保持框架的稳定性；Session各种存储的监控和报警支持；Session框架的可扩展性；跨域名Session与Cookie的共享。

由于应用是一个集群，所以不可能将创建的Session都保存在每台应用服务器的内存中，因为如果每台服务器有几十万的访问用户，服务器的内存肯定不够用，即使够用，这些Session也无法同步到这个应用的所有服务器中。所以要共享这些Session必须将他们存储在一个分布式缓存中，可以随时写入和读取，而且性能要很好才能满足要求，如MemCache、淘宝的Tair。

跨域名共享Cookie问题，Cookie是有域名限制的，一个域名下的Cookie不能被另一个域名访问。所以，如果在一个域名下已经登陆成功，如何访问到另外一个域名的应用且保证登陆状态仍然有效呢？

Cookie被盗问题？表单重复提交问题？



## JavaBean
> JavaBean与EJB（Enterprise JavaBean）没什么关系。JavaBean是为Java语言设计的软件组件模型，具有可重复使用和跨平台的特点。EJB是服务器端的构件，提供对事务、持久化、复制以及安全问题的支持。
> Enterprise Bean 与 JavaBean 不同。JavaBean 是使用 java.beans 包开发的，它是 Java 2 标准版的一部分。JavaBean 是一台机器上同一个地址空间中运行的组件。JavaBean 是进程内组件。Enterprise Bean 是使用 javax.ejb 包开发的，它是标准 JDK 的扩展，是 Java 2 Enterprise Edition 的一部分。Enterprise Bean 是在多台机器上跨几个地址空间运行的组件。因此 Enterprise Bean 是进程间组件。JavaBean 通常用作 GUI 窗口小部件，而 Enterprise Bean 则用作分布式商业对象.

一个bean就是一个可重用的软件构件，并且能够在开发工具中可视化地操作。（类似VB里的控件）bean就是一个在开发工具中可操作的类。
如果你的bean中的方法使用了标准的命名模式，那么开发工具就可以使用反射机制来确定bean的特征，例如属性以及事件。如果你需要更灵活的方式来描述有关bean的信息，可以定义一个实现了BeanInfo接口的对象。只要提供了这样的对象，开发工具就会通过询问它来识别你的bean具有的特性。

1. 它是一个简单的Java类，有Java类的一切特性，可使用封装、继承、多态等特性。
2. 必须是一个公开的类，访问权限为public。
3. 必须具有一个无参数的构造方法。
4. 一般将属性设置为私有的，通过使用 getXXX() 方法 和 setXXX() 方法进行属性的取得和设值。
 
    //一个简单的Javabean示例
    public class UserBean {
         private String username;
         public String getUsername() {
              retrun username;
         }
         public void setUsername(String username) {
              this.username = username;
         }
    }

在jsp中调用JavaBean：

    <jsp:useBean id="对象名称” scope=“存储范围" class=“类名”></jsp:useBean>

JavaBean的任务就是: “Write once, run anywhere, reuse everywhere”，即“一次性编写，任何地方执行，任何地方重用”。

JavaBean的持久化：用JavaBean的属性来将bean存储到流中，并在之后的某个时刻，或者在另一个虚拟机中再将它们读出来。它适合于长期存储。可以使用该机制存储任意对象的集合，只要遵守一些简单的规则即可。

在Java web 开发方面，几乎用不到多线程！因为有多线程的地方 servlet 容器或者其他开发框架都已经实现掉了。

推出JSP+BEAN，用JSP写presentation layer,用BEAN写business layer。



## 基础知识 

[java使用场景](http://solonote.iteye.com/blog/414170)

java跨平台，是因为jvm做了跨平台实现。Java代码都要写到class中。

Java中JDK,JRE和JVM之间的关系：![](https://t.alipayobjects.com/images/rmsweb/T1bNxiXeRcXXXXXXXX.png)

过程型语言：数据定义和函数调用。这些程序总是容易把人搞糊涂，因为它们使用的表示术语更加面向计算机而不是你要解决的问题。

因为OOP在你能够在过程型语言中找到的概念的基础上，又添加了许多新概念，所以你可能会很自然地假设：由此而产生的Java程序比等价的过程型程序要复杂得多。但是，编写良好的Java程序通常比过程型程序要简单得多，而且也易于理解得多。你看到的只是有关下面两部分内容的定义:用来表示问题空间概念的对象(而不是有关计算机表示方式的相关内容)，以及发送给这些对象的用来表示在此空间内的行为的消息。


设计方法(js叫函数)的原则：方法是实现某个功能的语句块的集合，设计方法的时候最好保持方法的「原子性」，即一个方法只完成一个功能，利于后期的扩展。

实例变量可以不用初始化而会被赋上默认值，局部变量(方法内定义的变量)必须要进行初始化。

用`static`修饰的方法叫做“类方法”，修饰的变量叫做“类变量”。类的对象上不存在static变量或方法。静态方法(static方法)里不能调用“非静态”的变量或方法；但非静态方法里可以调用静态变量或方法。

重写(override)和重载(overload)没有关系，重写是子类方法对父类同名方法的覆盖，重载是同一个类中几个同名方法有不同数目或类型的参数。

所有的类“构造器”第一句话都是`super()`，没有明确写则会默认加上，直到祖宗类`Object`没父类也就没super。普通的类方法里，也有隐式super参数供调用父类同名方法，但不必是方法的第一句话。

多态：举例，丈母娘：男朋友长得怎么样？女儿：有点象港台明星，丈母娘：哇！好明天带回家看看。女儿把男朋友带回家，丈母娘一看，疯了！原来是象“曾志伟”！

多态的存在要有3个必要条件：要有继承、要有方法重写、父类引用指向子类对象。

接口中只有：常量、抽象方法。

Map的底层结构是：数组 + 链表


### 内存
基本类型一旦声明就会被分配内存空间，而普通类型需要使用new关键字来分配内存空间。

在 Java中，所有的(普通)对象都储存在堆上。因此，new关键字的完整含义是，在堆上创建对象。

基本类型(primitive type)的对象，比如int, double，保存在栈上。当我们声明基本类型时，不需要new。一旦声明，Java将在栈上直接存储基本类型的数据。所以，基本类型的变量名表示的是数据本身，不是引用。

在JVM的一个进程空间中，一个栈(stack)代表了方法调用的次序。对于多线程来说，进程空间中需要有多个栈，以记录不同线程的调用次序。多个栈互不影响，但所有的线程将共享堆(heap)中的对象。


### 面向对象OOP
Java是完全的面向对象的语言，它使用`类和对象`、遵从`封装、继承、多态`的设计原则。类定义了对象的类型或种类、是定义对象的样板；同一个类的所有对象都有`相同的行为、相同种类的数据`(即有相同的方法和属性、但具体数据不同)

面向对象的3个基本要素：封装、继承、多态

面向对象的5个基本设计原则： 

- 单一职责原则（Single-Resposibility Principle） 
    - 一个类，最好只做一件事，只有一个引起它的变化。
- 开放封闭原则（Open-Closed principle） 
    - 对扩展开放，对修改封闭的
- 里氏替换原则（Liskov-Substituion Principle）
    - 子类必须能够替换其基类。
    - 子类可以扩展父类的功能，但不能改变父类原有的功能。 
- 依赖倒置原则（Dependecy-Inversion Principle） 
    - 高层模块不依赖于低层次模块，二者都同依赖于抽象接口。
    - 抽象接口不应该依赖于具体实现;而具体实现则应该依赖于抽象接口。 
- 接口隔离原则（Interface-Segregation Principle） 
    - 使用多个小的专门的接口，而不要使用一个大的总接口。 

#### 类设计技巧：
- 一定要保证数据私有。
- 一定要对数据初始化。Java不对局部变量进行初始化，但对对象的实例域进行初始化；但最好要自己去显式地初始化所有的数据。
- 不要在类中使用过多的基本类型。用其他的类代替多个相关的基本类型的使用。
- 不是所有的域都需要独立的域访问器和域更改器。
- 将职责过多的类进行分解。
- 类名和方法名命名要恰当、能体现他们的职责。

#### 封装：
类的数据域应该标记为`private`，以达到封装的目的，对其操作时，提供`公有的访问器方法(get)`、`公有的更改器方法（set）`。这样的好处是：可以改变内部实现，不影响其他代码；更改器方法可以执行错误检查。

注意不要编写返回引用可变对象的访问器方法（如Date类对象），要对它进行克隆（xx.clone()），返回克隆后的对象(存放在另一位置上的副本)。

final 修饰符大都应用于`基本类型`或`不可变类型(类中的每个方法都不会改变其对象，如String类)`，对于可变的类如`private final Date hiredate;`仅仅意味着存储在hiredate变量中的`对象引用`在对象构造之后不能改变，而并不意味着hiredate对象是一个常量，任何方法都可以对hiredate引用的对象调用setTime更改器。

#### 继承：
Java不支持多重继承，即派生类只能有一个基类。

Java中每个类都从类Object派生出。但来自object类的`equals()、toString()`不好用、需要被覆盖重写掉。

能够将派生类的对象赋值给任何祖先类型的变量，但相反方向的赋值不成立（例如：Student类构造为Person类的派生类，那么student是person，但person不一定是student）。student与person的关系为：「是其中一个关系（is-a relationship）」；象类MechanicalArm（机器人手臂）被类Robot（机器人）拥有，他们就是「拥有关系（has-a relationship）」；这就是术语「is-a 、has-a」的概念。

「is-a」关系是继承的一个明显特征，它可用来判断是否应该将类设计为继承关系。

> super 不是一个对象的引用，不能将 super 赋给另一个对象变量，它只是一个指示编译器调用超类方法、或超类的构造器的特殊关键字。

子类方法不能低于父类方法的可见性，例如：父类方法是public、子类也要是public。

当父类对象要调用子类中的方法时，要检查下父类的设计是否合理，在父类里添加上子类的方法。虽然能够但不该通过强制类型转换将父类对象类型转为子类类型；一般情况下、应该尽量少用类型转换和instanceof运算符。

在标准Java库中包含150多个equals方法的实现，他们使自己陷入困境。(Java核心技术第九版第5章172页)，给了编写完美 equals 方法的建议。


#### 多态
多态和「动态绑定」或「后期绑定」是相同的东西。例如Person类的数组，可以包含其派生类Student的对象。当调用`person[0].xx()`方法时，如果`person[0]`中存放的是Student类的对象，则`xx`方法是Student类中的实例方法，而不是Person类的实例方法。

在早期的Java中，有些人为了避免动态绑定带来的系统开销而使用final关键字声明方法。如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程称为内联。


### 数据类型：  
- 类类型(String等)
- 基本类型(byte int float double char boolean等)。

byte → short → int → long → float → double 左边类型的值 能赋给 右边类型的变量，能自动转换类型。但右边类型的值 想要赋给 左边类型的变量、需要强制类型转换。


### 内部类
内部类对象可以访问它所依附的外部类对象的成员(即使是private的成员)。从另一个角度来说，内部类对象附带有创建时的环境信息，也就是其他语言中的闭包(closure)特性。


### 反射
反射库（reflection library）提供了一个工具集，以便编写能够动态操纵Java代码的程序，这项功能被大量地应用于 JavaBeans 中。

#### 能够分析类能力的程序称为反射（reflective），反射可以用来：
- 在运行中分析类的能力
- 在运行中查看对象
- 实现通用的数组操作代码
- 利用 Method 对象，这个对象很像C++中的函数指针

### 泛型
使用泛型机制编写的程序代码要比那些杂乱地使用Object变量，然后再进行强制类型转换的代码具有更好的安全性和可读性，泛型对于集合类尤其有用，在表面上看来，泛型很像C++中的模板。

一个泛型类就是具有一个或多个类型变量的类, 如`public class Pair<T, U>{ ... }`。类型变量使用大写形式，且比较短，在Java库中，使用变量E表示集合的元素类型，K和V分别表示表的关键字与值的类型。T(需要时还可以用临近的字母U/S)表示「任意类型」。泛型类可看做普通类的工厂。

泛型方法，如`public static <T> T getMiddle(T... a){ }` 可以定义在普通的类中，也可以定义在泛型类中。

#### Java虚拟机泛型转换事实：
- 虚拟机中没有泛型，只有普通的类和方法
- 所有的类型参数都用它们的限定类型替换
- 桥方法被合成来保持多态
- 为保持类型安全性，必要时插入强制类型转换


## 流与文件
与C语言只有单一类型的 FILE* 包打天下不同，Java有一个流家族，包含各种流类型，其数量超过60个！把家族成员按使用方法来划分，就形成了处理「字节」和「字符」的两个单独层次结构。

在保存数据时，可以选用二进制格式或文本格式。例如，整数1234存储成二进制数时，它被写为由字节`00 00 04 D2`构成的序列（十六进制表示法），而存储成文本格式时，它被存成了字符串“1234”。尽管二进制格式的I/O高速且高效，但是不宜人来阅读。

RandomAccessFile 类可以在文件中的任何位置查找或写入数据。磁盘文件都是随机访问的，但是从网络而来的数据流却不是。随机访问文件有一个表示下一个将被读入或写出的字节所在位置的文件指针。

Path和Files是在Java SE 7中新添加进来的类，它们用起来比jkd1.0以来就一直使用的File类要方便得多。

多个同时执行的程序需要修改同一个文件的时，这些程序需要以某种方式进行通信，不然这个文件很容易被破坏。文件锁可以解决这个问题，它可以控制对文件或文件中某个范围的字节的访问。但文件加锁机制是依赖于操作系统的。

## 网络
几个名词：`TCP`、`UDP`、`套接字Socket`、`ip`、`URI`、`URL`、`URN`

IP地址和端口号组成了所谓的Socket，Socket是网络上运行的程序之间双向通信链路的终结点，是TCP和UDP的基础。

一个因特网地址由4个字节组成（ipv6中是16个字节），如`132.163.4.102`。一些访问量较大的主机名通常会对应于多个因特网地址，以实现负载均衡，如`google.com`一般会对应10几个不同的地址。

我们希望有多个客户端同时连接到我们的服务器上，就可以在程序建立一个新的套接字连接时，启动一个新的「线程」来处理服务器和客户端之间的连接，而主程序将立即返回并等待下一个连接。由于每一个连接都会启动一个新的线程，因而多个客户端就可以同时连接到服务器了。但每个连接生成一个单独的线程，这种方法并不能满足高性能服务器的要求。

半关闭提供了这样一种能力：套接字连接的一端可以终止其输出，同时仍旧可以接收来自另一端的数据。该协议只适用于一站式（one-shot）的服务，如http服务。

Java servlet、asp、CGI等统一称为「服务器端程序脚本」，可以让web服务器实现对程序的调用，用来对用户的输入进行处理。
在向web服务器发送信息时，通常会用到get或post方式。使用get方式时、只需把参数附在URL的结尾处即可，但有一个重要局限性：大多数浏览器都对get请求中可以包含的字符数做了限制。


## 安全
几个名词：`类加载器与安全管理器类`、`对类文件进行加密`、`字节码校验与校验器`、`安全策略文件`、`JAAS（Java认证和授权服务）`、`消息摘要和数字签名`、`RSA算法`、`DSA`、`认证问题`、`证书签名`、`代码签名`、`AES密匙`、`GSS-API`、`SASL`、`SSL`

一旦某个类被加载到虚拟机中，并由校验器检查过之后，Java平台的第二种安全机制「安全管理器」就会启动，它是一个负责控制具体操作是否允许执行的类。

消息摘要（message digest）是数据块的数字指纹。例如，SHA1（安全散列算法#1）可以将任何数据块，无论其数据有多长，都压缩为160位（20字节）的序列。消息摘要具有两个基本属性：

1. 如果数据的1位或者几位改变了，那么消息摘要也将改变。
2. 拥有给定消息的伪造者不能创建与原消息具有相同摘要的假消息。

用于计算这些消息摘要的最著名的两种算法是SHA1和MD5. 但由于一些规律的发现，密码人员建议最好避免使用MD5. Java已经实现了这两种算法。

如果消息和它的指纹(消息摘要)是分开传送的，那么接收者就可以检查消息是否被篡改过。但是如果消息和指纹同时被截获了，对消息进行修改，再重新计算指纹，就很容易，因为消息摘要算法是公开的。在这种情况下，假消息和新指纹的接收者永远不会知道消息已经被篡改，数字签名解决了这个问题。

公共密匙加密技术是基于「公共密匙」和「私有密匙」这两个基本概念。设计思想是可以将公共密匙告诉任何人，但只有自己才持有私有密匙，要保护你的私有密匙、不将它泄露给任何人。


## 脚本、编译与注解处理
#### 脚本API、脚本引擎
脚本API使你可以调用诸如`javascript`、`groovy`这样的脚本语言代码。脚本引擎是一个可以执行用某种特定语言编写的脚本的类库，当虚拟机启动时，它会发现可用的脚本引擎（引擎有`Rhino`、`Groovy`、`SISC Scheme`等）。脚本引擎可以直接调用脚本，可以调用脚本的函数和方法，可以编译脚本。

#### 编译器API
有许多工具都需要调用Java编译器，例如`开发环境`，`自动化构建和测试工具`、`处理Java代码段的模板工具（如JSP）`等。JSP引擎将HTML里混杂的Java代码编译到Servlet中。

#### 使用注解
注解是哪些插入到源代码中使用其他工具可以对其进行处理的标签。注解不会改变程序的编译方式。注解的使用范围还是很广泛的，如：`附属文件的自动生成，例如部署描述符或者bean信息类`，`测试、日志、事务语义等代码的自动生成`。Java EE使用注解极大地简化了编程模型。

除了能注解方法外，还可以注解类、成员以及局部变量，这些注解可以存在于任何可以放置一个象`public`或者`static`这样的修饰符的地方。每个注解都必须通过一个`注解接口`进行定义。关于注解语法......


## 分布式对象
几个名词：`代理（proxy）`、`CORBA与SOAP`、`远程方法调用（RMI）`、`远程对象激活`、


## 本地方法
Java平台有一个用于和本地C代码进行互操作的API，称为Java本地接口（JNI）。

从Java程序中调用C函数：`javah xxx`命令。Java与C不同的数据类型匹配。字符串参数的处理。访问域。编码签名。错误处理。




## 图形界面swing、awt
- 图形界面编程(java.awt、javax.swing)，并不是java的强项， vc++、delphi更适合。

### swing框架组件运用了典型的mvc「模型-视图-控制器」模式。还应用了另外几种模式：
- 容器和组件是「组合（composite）」模式
- 带滚动条的面板是「装饰器（decorator）」模式
- 布局管理器是「策略（strategy）」模式

对于组件如：JList、Jtree、JTable等，都采用了mvc模式，将可视化的外观（view）和底层数据（model 一个对象集合）进行了分离。


图形界面程序也大量用到了「内部类」。

组件的设计示例：对于JList组件，从理论上讲，把列表框的显示和滚动条机制隔离开来是优雅的设计，但在实际应用中却很难受，因为我们遇到的所有列表框基本上都需要滚动功能，所以每次都要手动将滚动条插入进来，比较麻烦。

有时为了查找树中的一个节点，必须从根节点开始，遍历所有子节点直到找到相匹配的节点。breadthFirstEnumeration方法和depthFirst Enumeration方法分别使用广度优先或深度优先的遍历方式，返回枚举对象。

JSpinner类似于html的input number控件。JSplitPane分割面板。

Graphics类和Java 2D API用来绘图。

有些文件，特别是gif动画文件，都包含了多个图像。ImageIO类的read方法只能够读取单一的图像文件。为了读取多个图像，应该将输入源（例如，输入流或输入文件）转换成一个ImageInputStream。
